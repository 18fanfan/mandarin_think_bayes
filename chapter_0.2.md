# 章節 0: 前言

## 0.2 模型建立與近似法

本書大多數的章節是被現實的問題所驅動，因此都需要有將現實問題轉化成模型的過程。在我們可以應用貝葉斯方法之前（或是其他的分析方法），我們需要決定現實問題中，哪些部分需要放到模型裡，又哪些部分的細節可以簡化。

例如第七章中，預測曲棍球比賽勝負的真實例子。作者將隊伍得分的分數用帕松過程 (Poisson Process) 建模，這意味著在比賽中的**每個時間點會得分的機率是一樣的**。這樣的假設並不完全真實，但在多數情況下或許已經是個足夠好的模型了。

為了凸顯簡化問題的結果，在第十二章中，一個預測 SAT 分數的例子（SAT 是在美國大學入學的標準化測驗，就類似台灣的學測）。作者一開始用一個簡單的模型，他假設在測驗中所有的題目難度是一樣的，但事實上 SAT 題目的出題者會刻意將某些問題設計的比較簡單，而某些問題比較困難。因此作者又提出了第二模型把上述的情況考慮進去，但其呈現最後效果**並沒有太大的差異**。

作者認為將建模的過程包含在解決問題的一部分是很重要的，因為這可以提醒我們考慮到建模時的錯誤（例如因為過度簡化或是假設錯誤所造成的問題）。本書中很多的方法都是運用離散分佈（discrete distribution）來處理，這或許讓一些人擔心數值誤差。但是現實的情形中，數值的誤差通常都小於建模時產生的誤差。除此之外，離散方法通常有機會做出更好的建模決策，作者認為有個好模型的近似解比壞模型的精準解來得好。

但另一方面來說，連續方法（continuous methods）有時會有效率上的優勢，例如用離散的算法的時間複雜度可能是 O(n) 或是 O(n^2) 就可能 O(1) 的連續方法所取代。

```
這邊可以舉個例子
```

所以，作者建議一個通用的流程，步驟如下：

- 當你在探索一個問題的時候，先從簡單的模型開始，用程式實作它，並且這些代碼是簡單的，容易理解的，結果驗證正確的。第一步是希望專注在建模決策上，而不是最佳化上。

```
Donald Knuth
The real problem is that programmers have spent far too much time worrying about efficiency in the wrong places and at the wrong times; premature optimization is the root of all evil (or at least most of it) in programming.
```

- 一但有一個可運作的簡單模型後，找出目前最大誤差發生的根源。例如你可能需要從連續函數中列舉更多的離散數值，或在增加蒙特卡羅模擬法的迭代次數，又或是加入更多的細節以貼近真實的問題。

- 如果目前方法的運算效率上已經足夠支持你的應用時，你不一定需要做後續的最佳化。但如果你想做最佳化，你有兩個思路提供給你參考：
  - 你可以檢視程式碼並且從中優化；例如你可以儲存(cache)之前計算的結果避免多餘的計算。
  - 運用解析方法(analytic method)取代某些離散的運算。

上述流程有兩個好處：

1. 第一步驟跟第二步驟可以在你真正投入某個模型之前，快速的嘗試不同的模型來比較效果。
2. 如果你進入到步驟三，你可以利用前兩步驟產生的簡單模型來對你後續最佳化模型做回歸測試(regression testing)，也就是說確保優化後的代碼是否產生近似的結果。
